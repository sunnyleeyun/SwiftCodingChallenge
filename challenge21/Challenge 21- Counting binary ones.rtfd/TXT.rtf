{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red148\green108\blue71;\red107\green0\blue109;\red135\green135\blue135;\red0\green0\blue255;
\red73\green17\blue135;\red169\green0\blue15;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c65098\c49804\c34902;\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;\cssrgb\c0\c0\c100000;
\cssrgb\c36078\c14902\c60000;\cssrgb\c72941\c0\c6667;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 21: Counting binary ones 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Tricky 
\f1\fs24 \

\f2\fs32 Create a function that accepts any positive integer and returns the next highest and next lowest number that has the same number of ones in its binary representation. If either number is not possible, return nil for it. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The number 12 is 1100 in binary, so it has two 1s. The next highest number with that many 1s is 17, which is 10001. The next lowest is 10, which is 1010. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The number 28 is 11100 in binary, so it has three 1s. The next highest number with that many 1s is 35, which is 100011. The next lowest is 26, which is 11010. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 You can find the binary representation of an integer by converting it to a string \'96 look for a \'93radix\'94 initializer. \uc0\u8232 
\f1\b Hint #2: 
\f2\b0 You should be using radix 2, which is binary.\uc0\u8232 
\f1\b Hint #3: 
\f2\b0 Your return value ought to be 
\f3\b \cf3 (nextHighest: Int?, nextLowest: 
\f2\b0 \cf2 \uc0\u8232 
\f3\b \cf3 Int?)
\f2\b0 \cf2 .\uc0\u8232 
\f1\b Hint #4: 
\f2\b0 You can count the 1s in a stringified number by using 
\f3\b \cf3 filter() 
\f2\b0 \cf2 on its \uc0\u8232 
\f3\b \cf3 characters 
\f2\b0 \cf2 property.\uc0\u8232 
\f1\b Hint #5: 
\f2\b0 Don\'92t be afraid to duplicate code while you\'92re working \'96 you need to search up and \uc0\u8232 down for the same thing, so start with duplication then refactor. \u8232 
\f1\b Hint #6: 
\f2\b0 You can\'92t create ranges where the end is higher than the start. Instead, create a forwards range then reverse it. \uc0\u8232 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Solution 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 This is a classic computing science problem, although I have to admit Swift makes it quite easy thanks to its range of 
\f3\b \cf3 String 
\f2\b0 \cf2 initializers. 
\f1\fs24 \

\f2\fs32 First and most importantly, you get the binary representation of an integer like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf4 \cb5 let \cf2 binaryString \cf6 = \cf7 String\cf8 (\cf2 someNumber\cf8 , \cf2 radix\cf8 : \cf9 2\cf8 )\cb1 \uc0\u8232 
\f2 \cf2 With that done, you can count the 1s by filtering by character and counting the resulting array: 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 All that leaves is finding the next highest and lowest, which can be done by counting upwards or downwards until the you back the same number of ones. 
\f1\fs24 \

\f2\fs32 Here\'92s the complete solution: 
\f1\fs24 \
\pard\pardeftab720\sl280\partightenfactor0
\cf2 {{\NeXTGraphic page68image6128.png \width9160 \height720
}¬}\pard\pardeftab720\sl280\partightenfactor0
\cf2 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 let \cf2 numberOfOnes \cf6 = \cf2 binaryString\cf8 .\cf2 characters\cf8 .\cf10 filter \cf8 \{ \cf2 $\cf9 0 \cf6 ==\
\pard\pardeftab720\sl360\partightenfactor0
\cf11 "1" \cf8 \}.\cf10 count\
\pard\pardeftab720\sl360\partightenfactor0
\cf4 \cb5 func \cf7 challenge21a\cf8 (\cf2 number\cf8 : \cf10 Int\cf8 ) \cf6 -> \cf8 (\cf2 nextHighest\cf8 : \cf10 Int\cf6 ?\cf8 ,\
\cf2 nextLowest\cf8 : \cf10 Int\cf6 ?\cf8 ) \{\
\cf4    let \cf2 targetBinary \cf6 = \cf7 String\cf8 (\cf2 number\cf8 , \cf2 radix\cf8 : \cf9 2\cf8 )\
\cf4    let \cf2 targetOnes \cf6 = \cf2 targetBinary\cf8 .\cf2 characters\cf8 .\cf10 filter \cf8 \{ \cf2 $\cf9 0 \cf6 ==\
\pard\pardeftab720\sl360\partightenfactor0
\cf11 "1" \cf8 \}.\cf10 count\
\pard\pardeftab720\sl360\partightenfactor0
\cf4    var \cf2 nextHighest\cf8 : \cf10 Int\cf6 ? = \cf9 nil\
\cf4    var \cf2 nextLowest\cf8 : \cf10 Int\cf6 ? = \cf9 nil\
\cf4    for \cf2 i \cf4 in \cf2 number \cf6 + \cf9 1\cf8 ...\cf10 Int\cf8 .\cf10 max \cf8 \{\
\cf4       let \cf2 currentBinary \cf6 = \cf7 String\cf8 (\cf2 i\cf8 , \cf2 radix\cf8 : \cf9 2\cf8 )\
\cf4       let \cf2 currentOnes \cf6 = \cf2 currentBinary\cf8 .\cf2 characters\cf8 .\cf10 filter \cf8 \{ \cf2 $\cf9 0 \cf6 ==\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf11 "1" \cf8 \}.\cf10 count 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5       if \cf2 targetOnes \cf6 == \cf2 currentOnes \cf8 \{\
\cf2          nextHighest \cf6 = \cf2 i\
\cf4          break\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4 \cf8 \cb5 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    for \cf2 i \cf4 in \cf8 (\cf9 0 \cf8 ..\cf6 < \cf2 number\cf8 ).\cf7 reversed\cf8 () \{\
\cf4       let \cf2 currentBinary \cf6 = \cf7 String\cf8 (\cf2 i\cf8 , \cf2 radix\cf8 : \cf9 2\cf8 )\
\cf4       let \cf2 currentOnes \cf6 = \cf2 currentBinary\cf8 .\cf2 characters\cf8 .\cf10 filter \cf8 \{ \cf2 $\cf9 0 \cf6 ==\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf11 "1" \cf8 \}.\cf10 count 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5       if \cf2 targetOnes \cf6 == \cf2 currentOnes \cf8 \{\
\cf2          nextLowest \cf6 = \cf2 i\
\cf4          break\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf8 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    return \cf8 (\cf2 nextHighest\cf8 , \cf2 nextLowest\cf8 )\
\}\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 Looking at that code, the duplication of binary counting does rather stick out. We can refactor it into a nested function to remove the duplication, although it only reduces the overall size of the solution by a little: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf7 challenge21b\cf8 (\cf2 number\cf8 : \cf10 Int\cf8 ) \cf6 -> \cf8 (\cf2 nextHighest\cf8 : \cf10 Int\cf6 ?\cf8 ,\
\cf2 nextLowest\cf8 : \cf10 Int\cf6 ?\cf8 ) \{\
\cf4    func \cf7 ones\cf8 (\cf4 in \cf2 number\cf8 : \cf10 Int\cf8 ) \cf6 -> \cf10 Int \cf8 \{\
\cf4       let \cf2 currentBinary \cf6 = \cf7 String\cf8 (\cf2 number\cf8 , \cf2 radix\cf8 : \cf9 2\cf8 )\
\cf4       return \cf2 currentBinary\cf8 .\cf2 characters\cf8 .\cf10 filter \cf8 \{ \cf2 $\cf9 0 \cf6 ==\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf11 "1" \cf8 \}.\cf10 count \cf8 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    let \cf2 targetOnes \cf6 = \cf7 ones\cf8 (\cf4 in\cf8 : \cf2 number\cf8 )\
\cf4    var \cf2 nextHighest\cf8 : \cf10 Int\cf6 ? = \cf9 nil\
\cf4    var \cf2 nextLowest\cf8 : \cf10 Int\cf6 ? = \cf9 nil\
\cf4    for \cf2 i \cf4 in \cf2 number \cf6 + \cf9 1\cf8 ...\cf10 Int\cf8 .\cf10 max \cf8 \{\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 if \cf7 ones\cf8 (\cf4 in\cf8 : \cf2 i\cf8 ) \cf6 == \cf2 targetOnes \cf8 \{\
\cf2          nextHighest \cf6 = \cf2 i\
\cf4          break\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf8 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    for \cf2 i \cf4 in \cf8 (\cf9 0 \cf8 ..\cf6 < \cf2 number\cf8 ).\cf7 reversed\cf8 () \{\
\cf4       if \cf7 ones\cf8 (\cf4 in\cf8 : \cf2 i\cf8 ) \cf6 == \cf2 targetOnes \cf8 \{\
\cf2          nextLowest \cf6 = \cf2 i\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf4 break 
\f1\fs24 \cf2 \cb1 \

\f4\fs32 \cf8 \cb5 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    return \cf8 (\cf2 nextHighest\cf8 , \cf2 nextLowest\cf8 )\
\}\
}