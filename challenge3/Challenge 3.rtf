{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red107\green0\blue109;\red135\green135\blue135;\red73\green17\blue135;\red148\green108\blue71;
\red0\green0\blue255;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c65098\c49804\c34902;
\cssrgb\c0\c0\c100000;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 3: Do two strings contain the same characters?\uc0\u8232 
\f1\fs32 Difficulty: 
\f2\b0 Easy 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 Write a function that accepts two 
\f3\b \cf3 String 
\f2\b0 \cf2 parameters, and returns true if they contain the same characters in any order taking into account letter case. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93abca\'94 and \'93abca\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93abc\'94 and \'93cba\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93 a1 b2 \'94 and \'93b 1 a 2\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93abc\'94 and \'93abca\'94 should return false. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93abc\'94 and \'93Abc\'94 should return false. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The strings \'93abc\'94 and \'93cbAa\'94 should return false. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 This task requires you to handle duplicate characters.\uc0\u8232 
\f1\b Hint #2: 
\f2\b0 The naive way to check this is to loop over the characters in one and check it exists in \uc0\u8232 the other, removing matches as you go.\u8232 
\f1\b Hint #3: 
\f2\b0 A faster solution is to convert both strings to character arrays. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 If you sort two character arrays, then you will have something that is the same length and identical character for character. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 You could write a na\'efve solution to this problem by taking a variable copy of the second input string, then looping over the first string and checking each letter exists in the second. If it does, remove it so it won\'92t be counted again; if not, return false. If you get to the end of the first string, then return true if the second string copy is now empty, otherwise return false. For example: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf6 challenge3a\cf7 (\cf2 string1\cf7 : \cf8 String\cf7 , \cf2 string2\cf7 : \cf8 String\cf7 ) \cf9 -> \cf8 Bool \cf7 \{\
\cf4    var \cf2 checkString \cf9 = \cf2 string2\
\cf4    for \cf2 letter \cf4 in \cf2 string1\cf7 .\cf2 characters \cf7 \{\
\cf4       if let \cf2 index \cf9 = \cf2 checkString\cf7 .\cf2 characters\cf7 .\cf6 index\cf7 (\cf2 of\cf7 : \cf2 letter\cf7 ) \{\
\cf2          checkString\cf7 .\cf2 characters\cf7 .\cf6 remove\cf7 (\cf2 at\cf7 : \cf2 index\cf7 )\
      \} \cf4 else \cf7 \{\
\cf4          return \cf10 false\
\cf7       \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5    return \cf2 checkString\cf7 .\cf2 characters\cf7 .\cf8 count \cf9 == \cf10 0\
\cf7 \}\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 That solution works, but is less than ideal because you\'92re having to look up letter positions repeatedly using 
\f3\b \cf3 index(of:)
\f2\b0 \cf2 , which is O(n). Worse, the 
\f3\b \cf3 remove(at:) 
\f2\b0 \cf2 call is also O(n), because it needs to move other elements down in the array once the item is removed. 
\f1\fs24 \

\f2\fs32 A more efficient solution is to make arrays out of both sets of string characters, then sort them. Once that\'92s done, you can do a direct comparison using 
\f3\b \cf3 ==
\f2\b0 \cf2 . This ends up not only being faster to run, but also involving much less code: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 func \cf6 challenge3b\cf7 (\cf2 string1\cf7 : \cf8 String\cf7 , \cf2 string2\cf7 : \cf8 String\cf7 ) \cf9 -> \cf8 Bool \cf7 \{\
\cf4    let \cf2 array1 \cf9 = \cf6 Array\cf7 (\cf2 string1\cf7 .\cf2 characters\cf7 )\
\cf4    let \cf2 array2 \cf9 = \cf6 Array\cf7 (\cf2 string2\cf7 .\cf2 characters\cf7 )\
\cf4    return \cf2 array1\cf7 .\cf6 sorted\cf7 () \cf9 == \cf2 array2\cf7 .\cf6 sorted\cf7 ()\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 For bonus interview points, you might be tempted to write something like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 return \cf2 array1\cf7 .\cf8 count \cf9 == \cf2 array2\cf7 .\cf8 count \cf9 && \cf2 array1\cf7 .\cf6 sorted\cf7 () \cf9 ==\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f0 \cf2 \cb1 www.hackingwithswift.com 18 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f4\fs32 \cf2 \cb5 array2\cf7 .\cf6 sorted\cf7 ()\cb1 \uc0\u8232 
\f2 \cf2 However, there\'92s no need \'96 the 
\f3\b \cf3 == 
\f2\b0 \cf2 operator for arrays does that before doing its item-by-item 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 comparison, so doing it yourself is just redundant. 
\f1\fs24 \
}