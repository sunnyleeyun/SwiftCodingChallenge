{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier;\f4\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red163\green0\blue79;\red255\green255\blue255;
\red107\green0\blue109;\red135\green135\blue135;\red73\green17\blue135;\red148\green108\blue71;\red0\green0\blue255;
\red0\green0\blue120;\red169\green0\blue15;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c70588\c0\c38431;\cssrgb\c100000\c100000\c100000;
\cssrgb\c50196\c0\c50196;\cssrgb\c60000\c60000\c60000;\cssrgb\c36078\c14902\c60000;\cssrgb\c65098\c49804\c34902;\cssrgb\c0\c0\c100000;
\cssrgb\c0\c0\c54510;\cssrgb\c72941\c0\c6667;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 23: Integer disguised as string 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Tricky\uc0\u8232 Write a function that accepts a string and returns true if it contains only numbers, i.e. the digits 
\f1\fs24 \

\f2\fs32 0 through 9. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The input \'9301010101\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The input \'93123456789\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The letter \'939223372036854775808\'94 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The letter \'931.01\'94 should return false; \'93.\'94 is not a number. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 You can create integers from strings, and Swift will return nil if the conversion failed. 
\f1\b Hint #2: 
\f2\b0 The number \'939223372036854775808\'94 is a precise choice, not just a random string of \uc0\u8232 numbers. \u8232 
\f1\b Hint #3: 
\f2\b0 Chances are Swift\'92s integer type will be 64-bit for you, and it\'92s signed, which means its maximum value is 2 to the power of 63, minus 1, i.e. 9223372036854775807 \'96 that\'92s one less than the test case you\'92ve been given. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 You should look into inverted character sets.\uc0\u8232 
\f1\b Hint #5: 
\f2\b0 Some languages write numbers differently from English. \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 There are lots of ways of solving this challenge, but if you want to solve it clearly, concisely, and correctly then your options are more limited. \u8232 There are two big gotchas when dealing with numbers. First, integers have a ceiling, beyond which they refuse to work. In Swift, the ceiling is 9,223,372,036,854,775,807, which is the largest number that can be represented by a signed 64-bit integer. The third test case I gave you was one higher than the maximum signed 64-bit integer, which was intentional. However, if you recognized that, you could have switched an unsigned integer and passed the challenge by writing code like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f3\fs32 \cf3 \cb4 func \cf5 challenge23\cf6 (\cf2 input\cf6 : \cf7 String\cf6 ) \cf8 -> \cf7 Bool \cf6 \{\
\cf3    return \cf5 UInt\cf6 (\cf2 input\cf6 ) \cf8 != \cf9 nil\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf6 \} \
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 I can\'92t think of a faster, simpler way to solve this challenge. However, it\'92s also a bit of a fudge \'96 all unsigned integers do is double the largest number you can address, so it would still fail if you added a 0 to the end of the existing big number. 
\f1\fs24 \

\f2\fs32 From there you might have migrated to using 
\f4\b \cf10 Int() 
\f2\b0 \cf2 to compare each individual letter in the string, like this: 
\f1\fs24 \cf2 \
\pard\pardeftab720\sl360\partightenfactor0

\f3\fs32 \cf3 \cb4 func \cf5 challenge23\cf6 (\cf2 input\cf6 : \cf7 String\cf6 ) \cf8 -> \cf7 Bool \cf6 \{\
\cf3    for \cf2 letter \cf3 in \cf2 input\cf6 .\cf2 characters \cf6 \{\
\cf3       if \cf5 Int\cf6 (\cf5 String\cf6 (\cf2 letter\cf6 )) \cf8 == \cf9 nil \cf6 \{\
\cf3          return \cf9 false\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf6 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f3\fs32 \cf3 \cb4 return \cf9 true \cf6 \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 As you can see, you can create integers from strings, and strings from characters, but you can\'92t create integers from characters \'96 d\'92oh. Still, though, this code runs fast: it bails out as soon as any non-matching letter is found, and only returns true if all digits converted to an integer successfully. 
\f1\fs24 \

\f2\fs32 An alternative solution is to use the 
\f4\b \cf10 rangeOfCharacter(from:) 
\f2\b0 \cf2 method, which lets you provide a character set and returns the location \'96 if any \'96 of those characters in the search string. In our case we know the numbers we want (digits), so we just need to get the inverse of that set using something like this: 
\f1\fs24 \
\
\pard\pardeftab720\sl360\partightenfactor0

\f3\fs32 \cf3 \cb4 func \cf5 challenge23\cf6 (\cf2 input\cf6 : \cf7 String\cf6 ) \cf8 -> \cf7 Bool \cf6 \{\
\cf3    return \cf2 input\cf6 .\cf5 rangeOfCharacter\cf6 (\cf2 from\cf6 :\
\cf7 CharacterSet\cf6 .\cf2 decimalDigits\cf6 .\cf2 inverted\cf6 ) \cf8 == \cf9 nil\
\cf6 \}\
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 This solution is interesting because it highlights another curiosity of numbers: Apple, being the smart company it is, considers \'93decimal digits\'94 to include numerals from other languages. I\'92m not sure how well this will print on your computer, but \'93\uc0\u1634 \'94 is the Arabic-Indic numeral 2. 
\f1\fs24 \

\f2\fs32 If you use the 
\f4\b \cf10 decimalDigits 
\f2\b0 \cf2 character set, it will include Arabic-Indic numerals as well as the numbers 0 through 9. While none of the test cases used Arabic-Indic numerals, if you wanted to conform strictly to the requirements for this challenge then you could use something like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f3\fs32 \cf6 \cb4 \
\cf3 func \cf5 challenge23\cf6 (\cf2 input\cf6 : \cf7 String\cf6 ) \cf8 -> \cf7 Bool \cf6 \{\
\cf3    return \cf2 input\cf6 .\cf5 rangeOfCharacter\cf6 (\cf2 from\cf6 :\
\cf5 CharacterSet\cf6 (\cf2 charactersIn\cf6 : \cf11 "0123456789"\cf6 ).\cf2 inverted\cf6 ) \cf8 == \cf9 nil\
\cf6 \}\
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2 \cf2 \cb1 Perhaps now you understand why I graded this challenge as tricky rather than easy! 
\f3 \cf6 \cb4 \
}