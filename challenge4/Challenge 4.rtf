{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf810
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\froman\fcharset0 Times-Roman;\f2\froman\fcharset0 TimesNewRomanPSMT;
\f3\fmodern\fcharset0 Courier-Bold;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue120;\red163\green0\blue79;
\red255\green255\blue255;\red73\green17\blue135;\red135\green135\blue135;\red107\green0\blue109;\red0\green0\blue255;
\red148\green108\blue71;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c54510;\cssrgb\c70588\c0\c38431;
\cssrgb\c100000\c100000\c100000;\cssrgb\c36078\c14902\c60000;\cssrgb\c60000\c60000\c60000;\cssrgb\c50196\c0\c50196;\cssrgb\c0\c0\c100000;
\cssrgb\c65098\c49804\c34902;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww15300\viewh16500\viewkind0
\deftab720
\pard\pardeftab720\sl560\sa240\partightenfactor0

\f0\b\fs48 \cf2 \expnd0\expndtw0\kerning0
Challenge 4: Does one string contain another? 
\f1\b0\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\b\fs32 \cf2 Difficulty: 
\f2\b0 Easy\uc0\u8232 Write your own version of the 
\f3\b \cf3 contains() 
\f2\b0 \cf2 method on 
\f3\b \cf3 String 
\f2\b0 \cf2 that ignores letter case, and 
\f1\fs24 \

\f2\fs32 without using the existing 
\f3\b \cf3 contains() 
\f2\b0 \cf2 method. 
\f1\fs24 \
\pard\pardeftab720\sl440\sa240\partightenfactor0

\f0\b\fs37\fsmilli18667 \cf2 Sample input and output 
\f1\b0\fs24 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl360\sa320\partightenfactor0
\ls1\ilvl0
\f2\fs32 \cf2 \kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 "Hello, world".fuzzyContains("Hello") 
\f2\b0 \cf2 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 "Hello, world".fuzzyContains("WORLD") 
\f2\b0 \cf2 should return true. \uc0\u8232 \
\ls1\ilvl0\kerning1\expnd0\expndtw0 {\listtext	\'95	}\expnd0\expndtw0\kerning0
The code 
\f3\b \cf3 "Hello, world".fuzzyContains("Goodbye") 
\f2\b0 \cf2 should return \uc0\u8232 false. \u8232 
\f0\b\fs37\fsmilli18667 Hints 
\f2\b0\fs32 \uc0\u8232 
\f1\b Hint #1: 
\f2\b0 You should write this as an extension to 
\f3\b \cf3 String
\f2\b0 \cf2 . \uc0\u8232 
\f1\b Hint #2: 
\f2\b0 You can\'92t use 
\f3\b \cf3 contains()
\f2\b0 \cf2 , but there are other methods that do similar things. \uc0\u8232 
\f1\b Hint #3: 
\f2\b0 Try the 
\f3\b \cf3 range(of:) 
\f2\b0 \cf2 method. \uc0\u8232 
\f1\b Hint #4: 
\f2\b0 To ignore case, you can either uppercase both strings, or try the second parameter to 
\f3\b \cf3 range(of:)
\f2\b0 \cf2 . \uc0\u8232 
\f0\b\fs37\fsmilli18667 Solution 
\f2\b0\fs32 \uc0\u8232 If you were already familiar with the 
\f3\b \cf3 range(of:) 
\f2\b0 \cf2 method, this one should have proved straightforward. If not, you were probably wondering why I gave it an easy grade! \uc0\u8232 The 
\f3\b \cf3 range(of:) 
\f2\b0 \cf2 method returns the position of one string inside another. As it\'92s possible the substring might not exist in the other, the return value is optional. This is perfect for us: if we call 
\f3\b \cf3 range(of:) 
\f2\b0 \cf2 and get back nil, it means the substring isn\'92t contained inside the check string. \uc0\u8232 Ignoring letter case adds a little complexity, but can be solved either by collapsing the case before you do your check, or by using the 
\f3\b \cf3 .caseInsensitive 
\f2\b0 \cf2 option for 
\f3\b \cf3 range(of:)
\f2\b0 \cf2 . 
\f1\fs24 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 The former looks like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 extension \cf6 String \cf7 \{\
\cf4    func \cf8 fuzzyContains\cf7 (\cf9 _ \cf2 string\cf7 : \cf6 String\cf7 ) \cf10 -> \cf6 Bool \cf7 \{\
\cf4       return self\cf7 .\cf8 uppercased\cf7 ().\cf8 range\cf7 (\cf2 of\cf7 : \cf2 string\cf7 .\cf8 uppercased\cf7 ()) \cf10 !\
= \cf9 nil\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 And the latter like this: 
\f1\fs24 \
\pard\pardeftab720\sl360\partightenfactor0

\f4\fs32 \cf4 \cb5 extension \cf6 String \cf7 \{\
\cf4    func \cf8 fuzzyContains\cf7 (\cf9 _ \cf2 string\cf7 : \cf6 String\cf7 ) \cf10 -> \cf6 Bool \cf7 \{\
\cf4       return \cf8 range\cf7 (\cf2 of\cf7 : \cf2 string\cf7 , \cf2 options\cf7 : .\cf2 caseInsensitive\cf7 ) \cf10 !=\
\cf9 nil\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf7 \} \} 
\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f2\fs32 \cf2 In this instance the two are identical, but there\'92s a benefit to collapsing the case if you had to check through lots of items. 
\f1\fs24 \
}